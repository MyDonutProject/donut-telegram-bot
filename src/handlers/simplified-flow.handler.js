// src/handlers/simplified-flow.handler.js
const Logger = require('../utils/logger');
const UserStateService = require('../services/user-state.service');
const MainKeyboard = require('../keyboards/main.keyboard');
const { formatters } = require('../utils/formatting');

class SimplifiedFlowHandler {
    constructor(bot) {
        this.bot = bot.bot;
        this.botInstance = bot;
        this.db = bot.db;
        this.walletService = bot.walletService;
        this.gamificationService = bot.gamificationService;
        this.userStateService = new UserStateService(bot.db);
        this.logger = new Logger('SimplifiedFlowHandler');
    }
    
    /**
     * Processar comando /start
     */
    async handleStart(msg, match) {
        const telegramId = msg.from.id.toString();
        const firstName = msg.from.first_name || 'amigo';
        
        try {
            // Obter estado atual do usu√°rio
            const flowState = await this.userStateService.getUserFlowState(telegramId);
            
            this.logger.info(`/start - Estado do usu√°rio ${telegramId}: ${flowState}`);
            
            // Verificar se tem par√¢metro (voucher de convite) - processado no bot.js
            const referralCode = match && match[1] ? match[1].trim() : null;
            if (referralCode && !referralCode.startsWith('voucher_')) {
                // Se n√£o √© voucher, pode ser outro tipo de refer√™ncia
                await this.handleReferralCode(telegramId, referralCode);
            }
            
            // Se √© novo usu√°rio, registrar
            if (flowState === 'new_user') {
                await this.registerNewUser(msg);
                await this.showInitialMessage(msg.chat.id, firstName);
            } 
            // Se est√° no onboarding, continuar de onde parou
            else if (flowState === 'onboarding_start') {
                await this.showInitialMessage(msg.chat.id, firstName);
            }
            // Usu√°rio com progresso
            else {
                await this.showProgressiveMenu(msg.chat.id, telegramId, flowState);
            }
            
        } catch (error) {
            this.logger.error('Erro no /start:', error);
            await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao iniciar. Tente novamente.');
        }
    }
    
    /**
     * Registrar novo usu√°rio
     */
    async registerNewUser(msg) {
        const telegramId = msg.from.id.toString();
        
        await this.db.run(`
            INSERT INTO users (
                telegram_id, telegram_username, first_name, last_name, language_code
            ) VALUES (?, ?, ?, ?, ?)
        `, [
            telegramId,
            msg.from.username || null,
            msg.from.first_name || null,
            msg.from.last_name || null,
            msg.from.language_code || 'pt'
        ]);
        
        // Inicializar tarefas
        await this.gamificationService.initializeUserTasks(telegramId);
        
        this.logger.info('Novo usu√°rio registrado:', telegramId);
    }
    
    /**
     * Tratar c√≥digo de refer√™ncia
     */
    async handleReferralCode(telegramId, referralCode) {
        try {
            // Salvar c√≥digo para usar depois
            this.botInstance.setUserState(telegramId, {
                referralVoucher: referralCode
            });
            
            await this.bot.sendMessage(telegramId,
                `üéØ *C√≥digo de convite detectado!*\n\n` +
                `Voc√™ foi convidado com o c√≥digo: \`${referralCode}\`\n` +
                `Ao criar sua matriz, voc√™ entrar√° na rede dessa pessoa!`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            this.logger.error('Erro ao processar c√≥digo de refer√™ncia:', error);
        }
    }
    
    /**
     * Mostrar mensagem inicial
     */
    async showInitialMessage(chatId, firstName) {
        const message = `üç© **Ol√° ${firstName}, est√° pronto para come√ßar a realizar algumas tarefas e participar do airdrop DONUT?**

üìù **Passos:**
‚Ä¢ Algumas tarefas simples
‚Ä¢ Investimento de $10 + $5 de taxas

üéÅ **B√¥nus:**
Assim que realizar as 7 primeiras tarefas, recupere $10 investidos + tokens DONUT!

Vamos come√ßar?`;
        
        const keyboard = {
            inline_keyboard: [
                [
                    { text: '‚úÖ Sim, vamos come√ßar!', callback_data: 'start_journey' }
                ]
            ]
        };
        
        await this.bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: keyboard
        });
    }
    
    /**
     * Processar callback "start_journey"
     */
    async handleStartJourney(chatId, telegramId, messageId) {
        const message = `üéâ **Bem-vindo ao Donut Matrix!**

Voc√™ est√° quase pronto para come√ßar sua jornada!

üéØ **Tarefa Inicial:**
Criar sua wallet Solana para entrar nessa doce comunidade

Vamos come√ßar?`;
        
        const keyboard = {
            inline_keyboard: [
                [
                    { text: 'üîß Realizar tarefa', callback_data: 'task_create_wallet' }
                ]
            ]
        };
        
        await this.editMessage(chatId, messageId, message, keyboard);
        
        // Marcar onboarding como iniciado
        await this.userStateService.saveUserState(telegramId, 'wallet_pending');
        await this.userStateService.completeOnboarding(telegramId);
    }
    
    /**
     * Processar tarefa de criar wallet
     */
    async handleWalletTask(chatId, telegramId, messageId) {
        // Verificar se j√° tem wallet
        const wallet = await this.walletService.getActiveWallet(telegramId);
        
        if (wallet) {
            // J√° tem wallet, avan√ßar para pr√≥xima tarefa
            await this.gamificationService.completeTask(telegramId, 'create_wallet');
            return await this.showNextTask(chatId, telegramId, messageId);
        }
        
        const message = `üí≥ **Sua primeira tarefa est√° a um passo de ser conclu√≠da**

Escolha uma das op√ß√µes abaixo para finalizar ela agora mesmo:`;
        
        const keyboard = {
            inline_keyboard: [
                [
                    { text: 'üÜï Criar Nova Wallet', callback_data: 'create_new_wallet' }
                ],
                [
                    { text: 'üì• Importar Wallet', callback_data: 'import_wallet_menu' }
                ],
                [
                    { text: '‚ùì O que √© uma wallet?', callback_data: 'wallet_info' }
                ],
                [
                    { text: 'üë• Grupo de Ajuda', url: 'https://t.me/donutmatrix' }
                ]
            ]
        };
        
        await this.editMessage(chatId, messageId, message, keyboard);
    }
    
    /**
     * Mostrar menu de importa√ß√£o simplificado
     */
    async showImportMenu(chatId, messageId) {
        const message = `üì• **Importar Wallet Existente**

Como voc√™ deseja importar sua wallet?

üí° **Importante:** Se sua wallet j√° tem SOL, a tarefa de funding ser√° completada automaticamente!`;
        
        const keyboard = {
            inline_keyboard: [
                [
                    { text: 'üîë Seed Phrase (12 palavras)', callback_data: 'import_seed' }
                ],
                [
                    { text: 'üîê Private Key', callback_data: 'import_private_key' }
                ],
                [
                    { text: 'üì± Como exportar da Phantom', callback_data: 'phantom_help' }
                ],
                [
                    { text: '‚¨ÖÔ∏è Voltar', callback_data: 'task_create_wallet' }
                ]
            ]
        };
        
        await this.editMessage(chatId, messageId, message, keyboard);
    }
    
    /**
     * Mostrar ajuda da Phantom
     */
    async showPhantomHelp(chatId, messageId) {
        const message = `üì± **Como Exportar da Phantom**

1Ô∏è‚É£ Abra o app Phantom
2Ô∏è‚É£ V√° em Configura√ß√µes ‚öôÔ∏è
3Ô∏è‚É£ Toque em "Seguran√ßa e Privacidade"
4Ô∏è‚É£ Selecione "Mostrar Frase Secreta"
5Ô∏è‚É£ Digite sua senha/biometria
6Ô∏è‚É£ Anote as 12 palavras em ordem

‚ö†Ô∏è **IMPORTANTE:**
‚Ä¢ Nunca compartilhe sua seed phrase
‚Ä¢ Anote em papel, n√£o tire print
‚Ä¢ Guarde em local seguro

Ap√≥s anotar, use a op√ß√£o "Seed Phrase" para importar.`;
        
        const keyboard = {
            inline_keyboard: [
                [
                    { text: 'üîë Importar com Seed Phrase', callback_data: 'import_seed' }
                ],
                [
                    { text: '‚¨ÖÔ∏è Voltar', callback_data: 'import_wallet_menu' }
                ]
            ]
        };
        
        await this.editMessage(chatId, messageId, message, keyboard);
    }
    
    /**
     * Mostrar informa√ß√£o sobre wallet
     */
    async showWalletInfo(chatId, messageId) {
        const message = `üìö **O que √© uma Wallet?**

Uma wallet (carteira) √© onde voc√™ armazena suas criptomoedas.

üîë **Componentes:**
‚Ä¢ **Seed Phrase:** 12/24 palavras para recuperar
‚Ä¢ **Private Key:** Chave secreta que controla
‚Ä¢ **Public Key:** Seu endere√ßo para receber

‚ö†Ô∏è **Seguran√ßa:**
‚Ä¢ Nunca compartilhe seed phrase ou private key
‚Ä¢ Anote em papel e guarde offline
‚Ä¢ Use PIN forte no bot

Pronto para criar sua wallet?`;
        
        const keyboard = {
            inline_keyboard: [
                [
                    { text: 'üÜï Criar Nova Wallet', callback_data: 'create_new_wallet' }
                ],
                [
                    { text: 'üì• Importar Wallet', callback_data: 'import_wallet_menu' }
                ],
                [
                    { text: '‚¨ÖÔ∏è Voltar', callback_data: 'task_create_wallet' }
                ]
            ]
        };
        
        await this.editMessage(chatId, messageId, message, keyboard);
    }

    /**
     * ‚úÖ Processar wallet ap√≥s importa√ß√£o
     */
    async handleWalletImported(chatId, telegramId, walletData) {
        try {
            // Verificar saldo da wallet importada
            const depositMonitor = this.botInstance.depositMonitorService;
            const checkResult = await depositMonitor.checkImportedWalletBalance(
                telegramId, 
                walletData.publicKey
            );

            if (checkResult.success && checkResult.completed) {
                // Wallet j√° tem saldo suficiente - pular para pr√≥xima tarefa
                this.logger.info(`Wallet importada com saldo completo: ${telegramId}`);
                
                // Atualizar estado do usu√°rio
                await this.userStateService.saveUserState(telegramId, 'funded');
                
                // N√£o precisa fazer mais nada, o depositMonitor j√° enviou a mensagem
                return { skipToNextTask: true };
            } 
            else if (checkResult.success && checkResult.partial) {
                // Wallet tem saldo parcial - monitoramento j√° iniciado
                this.logger.info(`Wallet importada com saldo parcial: ${telegramId}`);
                
                // Atualizar estado do usu√°rio
                await this.userStateService.saveUserState(telegramId, 'funding_pending');
                
                return { partialBalance: true };
            }
            else {
                // Wallet sem saldo - seguir fluxo normal
                this.logger.info(`Wallet importada sem saldo: ${telegramId}`);
                
                // Mostrar pr√≥xima tarefa (funding)
                await this.showNextTask(chatId, telegramId);
                
                return { needsFunding: true };
            }

        } catch (error) {
            this.logger.error('Erro ao processar wallet importada:', error);
            await this.bot.sendMessage(chatId, 
                '‚ö†Ô∏è Erro ao verificar saldo da wallet. Tente verificar manualmente.',
                {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'üîÑ Verificar Saldo', callback_data: 'check_funding' }],
                            [{ text: 'üìä Ver Progresso', callback_data: 'show_progress' }]
                        ]
                    }
                }
            );
        }
    }
    
    /**
     * Mostrar pr√≥xima tarefa
     */
    async showNextTask(chatId, telegramId, messageId) {
        const flowState = await this.userStateService.getUserFlowState(telegramId);
        const nextAction = this.userStateService.getNextAction(flowState);
        const progress = await this.gamificationService.getUserProgress(telegramId);
        
        let message = `üìä **Progresso: ${progress.progressPercent}%**\n\n`;
        message += `‚úÖ Tarefa conclu√≠da!\n\n`;
        message += `üéØ **Pr√≥xima tarefa:** ${nextAction.message}`;
        
        const keyboard = MainKeyboard.getNextTaskMenu(nextAction);
        
        if (messageId) {
            await this.editMessage(chatId, messageId, message, keyboard);
        } else {
            await this.bot.sendMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        }
    }
    
    /**
     * Mostrar menu progressivo baseado no estado
     */
    async showProgressiveMenu(chatId, telegramId, flowState) {
        const progress = await this.gamificationService.getUserProgress(telegramId);
        const nextAction = this.userStateService.getNextAction(flowState);
        const wallet = await this.walletService.getActiveWallet(telegramId);
        
        let message = `üç© **DONUT MATRIX BOT**\n\n`;
        message += `üìä **Progresso: ${progress.progressPercent}%**\n`;
        
        // Adicionar informa√ß√µes da wallet se existir
        if (wallet) {
            const balance = await this.walletService.getBalance(telegramId);
            if (balance.success) {
                message += `üí∞ **Saldo:** ${formatters.formatSOL(balance.solBalance.sol)}\n`;
            }
        }
        
        // Se completou todas as tarefas
        if (progress.progressPercent >= 100) {
            message += `\nüéâ **Parab√©ns! Todas as tarefas completas!**\n`;
            message += `Continue construindo sua rede para ganhos ilimitados!`;
        } else {
            message += `\nüéØ **Pr√≥xima a√ß√£o:** ${nextAction.message}`;
        }
        
        const keyboard = MainKeyboard.getProgressiveMenu(
            flowState,
            nextAction,
            wallet,
            progress.progressPercent
        );
        
        await this.bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: keyboard
        });
    }
    
    /**
     * ‚úÖ Acesso a funcionalidade
     */
    async checkFeatureAccess(chatId, telegramId, feature, messageId = null) {
        const walletFeatures = [
            'send_tokens', 'receive_tokens', 'view_balance',
            'manage_wallet', 'wallet_menu', 'wallet_settings'
        ];
        
        if (walletFeatures.includes(feature)) {
            const wallet = await this.walletService.getActiveWallet(telegramId);
            if (!wallet) {
                const message = '‚ùå Voc√™ precisa criar uma wallet primeiro!';
                const keyboard = {
                    inline_keyboard: [
                        [{ text: 'üí≥ Criar Wallet', callback_data: 'task_create_wallet' }],
                        [{ text: '‚¨ÖÔ∏è Voltar', callback_data: 'main_menu' }]
                    ]
                };
                
                if (messageId) {
                    await this.editMessage(chatId, messageId, message, keyboard);
                } else {
                    await this.bot.sendMessage(chatId, message, {
                        parse_mode: 'Markdown',
                        reply_markup: keyboard
                    });
                }
                return false;
            }
            return true; // Tem wallet, pode acessar
        }
        
        // Verifica√ß√£o para outras features
        const canAccess = await this.userStateService.canAccessFeature(telegramId, feature);
        
        if (!canAccess) {
            const message = this.userStateService.getBlockedFeatureMessage(feature);
            const flowState = await this.userStateService.getUserFlowState(telegramId);
            const nextAction = this.userStateService.getNextAction(flowState);
            
            const keyboard = {
                inline_keyboard: [
                    [{ text: `üéØ ${nextAction.message}`, callback_data: nextAction.callback }],
                    [{ text: '‚¨ÖÔ∏è Voltar', callback_data: 'main_menu' }]
                ]
            };
            
            if (messageId) {
                await this.editMessage(chatId, messageId, message, keyboard);
            } else {
                await this.bot.sendMessage(chatId, message, {
                    parse_mode: 'Markdown',
                    reply_markup: keyboard
                });
            }
            
            return false;
        }
        
        return true;
    }
    
    /**
     * Processar tarefas
     */
    async handleDevelopmentTask(chatId, telegramId, taskType, messageId) {

        switch(taskType) {
            case 'create_matrix':
                if (this.botInstance.matrixHandler) {
                    return await this.botInstance.matrixHandler.handleMatrixTask(chatId, telegramId, messageId);
                }
                break;
                
            case 'create_voucher':
                if (this.botInstance.voucherHandler) {
                    return await this.botInstance.voucherHandler.handleVoucherTask(chatId, telegramId, messageId);
                }
                break;
                
            case 'first_referral':
            case 'second_referral':
            case 'third_referral':
                return await this.showReferralTask(chatId, telegramId, taskType, messageId);
                
            default:
                break;
        }
        
        // Fallback para tarefas n√£o implementadas
        const message = `üöß **Funcionalidade em desenvolvimento**\n\nEm breve dispon√≠vel!`;
        
        const keyboard = {
            inline_keyboard: [
                [
                    { text: 'üë• Grupo de Ajuda', url: 'https://t.me/donutmatrix' }
                ],
                [
                    { text: '‚¨ÖÔ∏è Menu Principal', callback_data: 'main_menu' }
                ]
            ]
        };
        
        await this.editMessage(chatId, messageId, message, keyboard);
    }
    
    /**
     * Mostrar tarefa de refer√™ncia
     */
    async showReferralTask(chatId, telegramId, taskType, messageId) {
        // Verificar se tem voucher
        const voucher = await this.botInstance.voucherService.getUserVoucher(telegramId);
        
        if (!voucher) {
            const message = '‚ùå **Voucher Necess√°rio**\n\nVoc√™ precisa criar um voucher primeiro para convidar pessoas!';
            const keyboard = {
                inline_keyboard: [
                    [{ text: 'üé´ Criar Voucher', callback_data: 'task_create_voucher' }],
                    [{ text: '‚¨ÖÔ∏è Voltar', callback_data: 'main_menu' }]
                ]
            };
            return await this.editMessage(chatId, messageId, message, keyboard);
        }
        
        // Verificar quantos referidos j√° tem
        const stats = await this.botInstance.voucherService.getVoucherStats(telegramId);
        const taskNumber = {
            'first_referral': 1,
            'second_referral': 2,
            'third_referral': 3
        }[taskType];
        
        let message = `üë• **Tarefa: ${taskNumber}¬∫ Refer√™ncia**\n\n`;
        
        if (stats.matricesCreated >= taskNumber) {
            message += '‚úÖ **Tarefa j√° completada!**\n\n';
            message += `Voc√™ j√° tem ${stats.matricesCreated} pessoas na sua matriz.`;
        } else {
            message += `üìä **Progresso:** ${stats.matricesCreated}/${taskNumber}\n\n`;
            message += 'üì§ **Compartilhe seu link:**\n';
            message += `\`${voucher.referral_link}\`\n\n`;
            message += `‚è≥ Aguardando ${taskNumber - stats.matricesCreated} pessoa(s) criar matriz...`;
        }
        
        const keyboard = {
            inline_keyboard: [
                [{ text: 'üìã Copiar Link', callback_data: 'copy_voucher_link' }],
                [{ text: 'üì§ Compartilhar', callback_data: 'share_voucher' }],
                [{ text: 'üìä Ver Estat√≠sticas', callback_data: 'view_voucher_stats' }],
                [{ text: '‚¨ÖÔ∏è Menu Principal', callback_data: 'main_menu' }]
            ]
        };
        
        await this.editMessage(chatId, messageId, message, keyboard);
    }
    
    /**
     * Helper para editar mensagem
     */
    async editMessage(chatId, messageId, text, keyboard = null) {
        const options = {
            chat_id: chatId,
            message_id: messageId,
            parse_mode: 'Markdown'
        };
        
        if (keyboard) {
            options.reply_markup = keyboard;
        }
        
        try {
            return await this.bot.editMessageText(text, options);
        } catch (error) {
            if (!error.message.includes('message is not modified')) {
                this.logger.error('Erro ao editar mensagem:', error);
            }
            // Se falhar, enviar nova mensagem
            return await this.bot.sendMessage(chatId, text, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        }
    }
}

module.exports = SimplifiedFlowHandler;